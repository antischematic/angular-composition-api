"use strict";(self.webpackChunkpackages_docs=self.webpackChunkpackages_docs||[]).push([[664],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},543:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),o=["components"],s={sidebar_position:6},l="Subscriptions",p={unversionedId:"subscriptions",id:"subscriptions",isDocsHomePage:!1,title:"Subscriptions",description:"RxJS Observable is the fundamental reactive primitive in Angular. This makes it easy to compose reactive data streams",source:"@site/docs/subscriptions.md",sourceDirName:".",slug:"/subscriptions",permalink:"/angular-composition-api/docs/subscriptions",editUrl:"https://github.com/mmuscat/angular-composition-api/tree/master/docs/subscriptions.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Providers",permalink:"/angular-composition-api/docs/providers"},next:{title:"Lifecycle Hooks",permalink:"/angular-composition-api/docs/lifecycle"}},c=[{value:"Subscribe",id:"subscribe",children:[]},{value:"Initial Observer",id:"initial-observer",children:[]},{value:"Reactive Observer",id:"reactive-observer",children:[]},{value:"Error Handling",id:"error-handling",children:[{value:"Uncaught errors",id:"uncaught-errors",children:[]}]},{value:"Composition",id:"composition",children:[]},{value:"Abort Signals",id:"abort-signals",children:[]}],m={toc:c};function u(e){var n=e.components,t=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"subscriptions"},"Subscriptions"),(0,i.kt)("p",null,"RxJS ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable")," is the fundamental reactive primitive in Angular. This makes it easy to compose reactive data streams\nthat perform complex async tasks, but presents some hurdles when consuming them in a component. Some common problems\nare:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Subscribing too early or too late"),(0,i.kt)("li",{parentName:"ul"},"Subscribing to cold observables multiple times unintentionally"),(0,i.kt)("li",{parentName:"ul"},"Accessing the current value of an observable stream"),(0,i.kt)("li",{parentName:"ul"},"Subscription management"),(0,i.kt)("li",{parentName:"ul"},"Error recovery")),(0,i.kt)("p",null,"The usual solution to these problems is to use a ",(0,i.kt)("inlineCode",{parentName:"p"},"BehaviorSubject")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ReplaySubject"),". Orchestrating a chain of\nobservables and subjects however is quite involved when interacting with component inputs, lifecycles, change\ndetection and templates."),(0,i.kt)("p",null,"Angular composition API abstracts these problems away by introducing a consistent pattern for creating, observing and\nupdating reactive state, using smart subscriptions."),(0,i.kt)("h2",{id:"subscribe"},"Subscribe"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," method is the entry point for observing reactive state with Angular Composition API. This method takes\nand observable stream and subscribes to its values. These values are passed to an observer, where reactive state can\nbe mutated before change detection runs. If the observer returns ",(0,i.kt)("inlineCode",{parentName:"p"},"TeardownLogic"),", this will be executed the next time\nthe observer receives a value, or when the subscription ends."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example: Log the value of count whenever it changes"',title:'"Example:',Log:!0,the:!0,value:!0,of:!0,count:!0,whenever:!0,it:!0,'changes"':!0},'import { Component } from "@angular/core"\nimport { subscribe, use, ViewDef } from "@mmuscat/angular-composition-api"\n\nfunction setup() {\n   const count = use(0)\n\n   subscribe(count, console.log)\n\n   return {\n      count,\n   }\n}\n\n@Component({\n   inputs: ["count"],\n})\nexport class MyComponent extends ViewDef(setup) {}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example: RxJS interop with partial observer"',title:'"Example:',RxJS:!0,interop:!0,with:!0,partial:!0,'observer"':!0},'import { Component } from "@angular/core"\nimport { HttpClient } from "@angular/common/http"\nimport { subscribe, use, ViewDef } from "@mmuscat/angular-composition-api"\nimport { interval } from "rxjs"\nimport { switchMap } from "rxjs/operators"\n\nfunction setup() {\n   const http = inject(HttpClient)\n   const result = use<{ data: any }>()\n   const pollData = interval(10000).pipe(\n      switchMap(() => http.get("http://www.example.com/api/data")),\n   )\n\n   subscribe(pollData, {\n      next: result,\n      error(error) {\n         console.error(error)\n      },\n   })\n\n   return {\n      result,\n   }\n}\n\nexport class MyComponent extends ViewDef(setup) {}\n')),(0,i.kt)("h2",{id:"initial-observer"},"Initial Observer"),(0,i.kt)("p",null,"Alternatively ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," can be called with a single function argument. This will be executed once when the component\nis mounted. This is useful for safely mounting third-party DOM libraries. Cleanup can be performed by returning\n",(0,i.kt)("inlineCode",{parentName:"p"},"TeardownLogic")," from the observer, which will run when the component is destroyed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example: Initial observer"',title:'"Example:',Initial:!0,'observer"':!0},'import { Component, ElementRef } from "@angular/core"\nimport { subscribe, ViewDef } from "@mmuscat/angular-composition-api"\n\nfunction setup() {\n   const { nativeElement } = inject(ElementRef)\n   subscribe(() => {\n      const ref = thirdPartyDOMLibrary(nativeElement)\n      return () => ref.destroy()\n   })\n   return {}\n}\n\n@Component()\nexport class MyComponent extends ViewDef(setup) {}\n')),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If used in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Service")," the initial observer is called once immediately after the service is instantiated."))),(0,i.kt)("h2",{id:"reactive-observer"},"Reactive Observer"),(0,i.kt)("p",null,"When an initial observer has data dependencies, it becomes a reactive observer. A reactive observer shares the same\nlifecycle as an initial observer, but is also called recursively whenever one of its data dependencies change. A data\ndependency is created whenever the getter function of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Value")," is called within a reactive\nobserver's call context."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example: Reactive observer with value dependency"',title:'"Example:',Reactive:!0,observer:!0,with:!0,value:!0,'dependency"':!0},'import { Component, ContentChildren } from "@angular/core"\nimport { subscribe, use, ViewDef } from "@mmuscat/angular-composition-api"\nimport { Child } from "./child.component"\n\nfunction setup() {\n   const children = use<Child>(ContentChildren)\n\n   subscribe(() => {\n      for (const child of children()) {\n         console.log(child)\n      }\n   })\n\n   return {\n      children,\n   }\n}\n\n@Component({\n   queries: {\n      children: new ContentChildren(Child),\n   },\n})\nexport class Parent extends ViewDef(setup) {}\n')),(0,i.kt)("p",null,"In the above example the ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," value is marked as a data dependency of the reactive observer. Whenever the value\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," changes, the observer function will be called again."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"To get a better understanding, another application of reactive observers comes from the ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," utility function."),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { Component } from "@angular/core"\nimport { select, use, ViewDef } from "@mmuscat/angular-composition-api"\n\nfunction setup() {\n   const count = use(0)\n   const doubled = select(() => count() * 2)\n\n   return {\n      count,\n      doubled,\n   }\n}\n\n@Component({\n   inputs: ["count"],\n})\nexport class MyComponent extends ViewDef(setup) {}\n')),(0,i.kt)("p",{parentName:"div"},"The value of ",(0,i.kt)("inlineCode",{parentName:"p"},"doubled")," is derived from ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," using a reactive observer. Keep in mind that only ",(0,i.kt)("inlineCode",{parentName:"p"},"Value")," can be used\nin this way. RxJS observables can be converted to a ",(0,i.kt)("inlineCode",{parentName:"p"},"Value")," with the ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," function."))),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"To prevent a ",(0,i.kt)("inlineCode",{parentName:"p"},"Value")," being marked as a dependency, access its value with the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," property accessor instead."))),(0,i.kt)("h2",{id:"error-handling"},"Error Handling"),(0,i.kt)("p",null,"All the standard RxJS methods for error handling are available, such ",(0,i.kt)("inlineCode",{parentName:"p"},"catchError")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"retry"),". However sometimes we\ndon't want to restart the subscription when an error occurs, for example, when using a ",(0,i.kt)("inlineCode",{parentName:"p"},"BehaviorSubject")," as the source.\nWhile this can be managed it is prone to error and verbose."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," method is different from RxJS subscribe in that it will also accept a materialized stream. If a stream\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Notification")," is received, ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," will dematerialize it and call the appropriate methods on the observer,\nwithout ending the stream. This makes it possible to keep a stream alive and handle errors in the observer instead of\ndealing with the complexities of ",(0,i.kt)("inlineCode",{parentName:"p"},"catchError"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example: Error handling with a materialized stream"',title:'"Example:',Error:!0,handling:!0,with:!0,a:!0,materialized:!0,'stream"':!0},'import { Component } from "@angular/core"\nimport { HttpClient } from "@angular/common/http"\nimport { subscribe, use, ViewDef } from "@mmuscat/angular-composition-api"\nimport { interval } from "rxjs"\nimport { switchMap, materialize } from "rxjs/operators"\n\nfunction setup() {\n   const http = inject(HttpClient)\n   const result = use<{ data: any }>()\n   const pollData = interval(10000).pipe(\n      switchMap(() =>\n         http.get("http://www.example.com/api/data").pipe(materialize()),\n      ),\n   )\n\n   subscribe(pollData, {\n      next: result,\n      error(error) {\n         console.error(error)\n      },\n   })\n\n   return {\n      result,\n   }\n}\n\nexport class MyComponent extends ViewDef(setup) {}\n')),(0,i.kt)("p",null,"This is the same example from before, except this time errors are materialized, allowing the stream to continue even\nif there's an error. The observer will receive the same values as before."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"materialize")," operator must be place on an inner-observable, such as within a ",(0,i.kt)("inlineCode",{parentName:"p"},"switchMap"),", to prevent the\nouter observable closing on error."))),(0,i.kt)("h3",{id:"uncaught-errors"},"Uncaught errors"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," method catches and notifies of uncaught errors. All uncaught errors are piped to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ErrorHandler"),"\nservice. To prevent this, ensure that all error-able streams have an error observer, or are handled upstream."),(0,i.kt)("h2",{id:"composition"},"Composition"),(0,i.kt)("p",null,"The execution context of components, directives and services also extends to subscriptions."),(0,i.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Every observer called by ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," runs in its own execution context!"))),(0,i.kt)("p",null,"This means that it's possible to nest calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," inside one another."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { HttpClient } from "@angular/common/http"\nimport { Compnonent } from "@angular/core"\nimport { subscribe, use, ViewDef } from "@mmuscat/angular-composition-api"\n\nfunction setup() {\n   const http = inject(HttpClient)\n   const userId = use()\n   const result = use()\n\n   subscribe(userId, (id) => {\n      if (id) {\n         const loadUser = http.post("http://www.example.com/api/data", { id })\n         subscribe(loadUser, {\n            next: result,\n            error(error) {\n               console.error(error)\n            },\n         })\n      }\n   })\n\n   return {\n      userId,\n      result,\n   }\n}\n\n@Component()\nexport class MyComponent extends ViewDef(setup) {}\n')),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"userId")," emits a new value, a new subscription ",(0,i.kt)("inlineCode",{parentName:"p"},"loadUser")," is created, automatically cancelling the previous\nsubscription. It is like a more ergonomic version of ",(0,i.kt)("inlineCode",{parentName:"p"},"switchMap"),"."),(0,i.kt)("h2",{id:"abort-signals"},"Abort Signals"),(0,i.kt)("p",null,"By default, the lifecycle of a subscription is controlled by its context, for example, subscriptions in a component\ncontext are cleaned up when the component is destroyed. This behavior can be overridden by passing an abort signal as\na third argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe"),". The abort signal can be an ",(0,i.kt)("inlineCode",{parentName:"p"},"AbortSignal")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"AbortController")," or another\n",(0,i.kt)("inlineCode",{parentName:"p"},"Subscription"),"."),(0,i.kt)("p",null,"This is useful when we don't want the default ",(0,i.kt)("inlineCode",{parentName:"p"},"switchMap")," behavior of composed subscriptions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example: Merge inner subscriptions"',title:'"Example:',Merge:!0,inner:!0,'subscriptions"':!0},'import { Compnonent } from "@angular/core"\nimport { subscribe, use, ViewDef } from "@mmuscat/angular-composition-api"\n\nfunction setup() {\n   const ping = inject(PingService)\n   const signal = subscribe() // cancels when view is destroyed\n   const responseTime = use<number>()\n\n   subscribe(interval(1000), () => {\n      subscribe(ping.pong(), responseTime, signal)\n   })\n\n   return {\n      responseTime,\n   }\n}\n\n@Component()\nexport class Pinger extends ViewDef(setup) {}\n')),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Automatic cleanup of subscriptions can be disabled entirely by passing ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," to the abort signal argument, but this\ncan cause memory leaks. Use with care."))))}u.isMDXComponent=!0}}]);